/*-----------------------------------------------------------------------------/
    This code was generated by a tool: http://enc.drachev.com/
    You can get a fresh version any time you want.

    Changes to this file may cause incorrect behavior and will be lost if
    the code is regenerated.
 
    Anton Drachev, as the author of this code, expressly permits 
    you to use this code as public domain code.

    Supported codepages: 
        1200
        1201
        1251
        20127
        65001
    Generated: Tue, 28 Feb 2012 13:16:35 GMT
/-----------------------------------------------------------------------------*/

using System;
using System.Collections.Generic;
using System.Globalization;

namespace ChsuStudent.Utils
{
    public abstract class Encoding
    {
        #region toString

        public virtual char[] GetChars(byte[] bytes)
        {
            return GetChars(bytes, 0, bytes.Length);
        }

        public abstract char[] GetChars(byte[] bytes, int index, int count);

        public virtual int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex)
        {
            var tmp = GetChars(bytes, byteIndex, byteCount);
            Array.Copy(tmp, 0, chars, charIndex, tmp.Length);
            return tmp.Length;
        }

        public virtual string GetString(byte[] bytes)
        {
            return GetString(bytes, 0, bytes.Length);
        }

        public virtual string GetString(byte[] bytes, int start, int count)
        {
            return new string(GetChars(bytes, start, count));
        }

        public virtual byte[] GetBytes(char[] chars)
        {
            return GetBytes(chars, 0, chars.Length);
        }

        #endregion

        #region toBytes

        public virtual byte[] GetBytes(string s)
        {
            var tmp = s.ToCharArray();
            return GetBytes(tmp, 0, tmp.Length);
        }

        public abstract byte[] GetBytes(char[] chars, int index, int count);

        public virtual int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex)
        {
            var tmp = GetBytes(chars, charIndex, charCount);
            Array.Copy(tmp, 0, bytes, byteIndex, tmp.Length);
            return tmp.Length;
        }

        public virtual int GetBytes(string s, int charIndex, int charCount, byte[] bytes, int byteIndex)
        {
            return GetBytes(s.ToCharArray(), charIndex, charCount, bytes, byteIndex);
        }

        #endregion

        #region counts

        public virtual int GetByteCount(char[] chars)
        {
            return GetByteCount(chars, 0, chars.Length);
        }

        public virtual int GetByteCount(String s)
        {
            var tmp = s.ToCharArray();
            return GetByteCount(tmp, 0, tmp.Length);
        }

        public abstract int GetByteCount(char[] chars, int index, int count);

        public virtual int GetCharCount(byte[] bytes)
        {
            return GetCharCount(bytes, 0, bytes.Length);
        }

        public abstract int GetCharCount(byte[] bytes, int index, int count);

        #endregion

        #region names

        public abstract int CodePage { get; }
        public abstract string EncodingName { get; }
        public abstract string WebName { get; }

        private static readonly object syncRoot = new object();

        private static Dictionary<string, int> NameMap;

        public static Encoding GetEncoding(string name)
        {
            if (NameMap == null)
                lock (syncRoot)
                    if (NameMap == null)
                        NameMap = new Dictionary<string, int> {
                            { "unicode", 1200 },
                            { "utf-16", 1200 },
                            { "cp1200", 1200 },
                            { "ucs-2", 1200 },
                            { "utf-16le", 1200 },
                            { "unicodefffe", 1201 },
                            { "utf-16be", 1201 },
                            { "cp1201", 1201 },
                            { "windows-1251", 1251 },
                            { "x-cp1251", 1251 },
                            { "cp1251", 1251 },
                            { "us-ascii", 20127 },
                            { "ansi_x3.4-1968", 20127 },
                            { "ansi_x3.4-1986", 20127 },
                            { "ascii", 20127 },
                            { "cp367", 20127 },
                            { "csascii", 20127 },
                            { "ibm367", 20127 },
                            { "iso_646.irv:1991", 20127 },
                            { "iso646-us", 20127 },
                            { "iso-ir-6", 20127 },
                            { "us", 20127 },
                            { "utf-8", 65001 },
                            { "unicode-1-1-utf-8", 65001 },
                            { "unicode-2-0-utf-8", 65001 },
                            { "x-unicode-2-0-utf-8", 65001 },
                            { "cp65001", 65001 },
                        };
            name = name.ToLower(CultureInfo.InvariantCulture);
            if (NameMap.ContainsKey(name))
                return GetEncoding(NameMap[name]);
            throw new ArgumentException("'" + name + "' is not a supported encoding name.", "name");
        }

        public static Encoding GetEncoding(int codepage)
        {
            switch (codepage) {
                case 0: return Default;
                case 1200: return Unicode;
                case 1201: return BigEndianUnicode;
                case 65001: return UTF8;
                case 20127: return ASCII;
                case 1251: return Enc1251.Value ?? (Enc1251.Value = new Enc1251());
                default:
                    if (0 <= codepage && codepage <= 65535)
                        throw new NotSupportedException("No data is available for encoding " + codepage + ".");
                    throw new ArgumentException("Valid values are between 0 and 65535, inclusive.", "codepage");
            }
        }

        #endregion

        public static readonly Encoding ASCII = new Enc20127();
        public static readonly Encoding BigEndianUnicode = new EncodingWrapper(System.Text.Encoding.BigEndianUnicode);
        public static readonly Encoding Default = UTF8;
        public static readonly Encoding Unicode = new EncodingWrapper(System.Text.Encoding.Unicode);
        public static readonly Encoding UTF8 = new EncodingWrapper(System.Text.Encoding.UTF8);

        private sealed class EncodingWrapper : Encoding
        {
            readonly System.Text.Encoding enc;

            public EncodingWrapper(System.Text.Encoding enc)
            {
                this.enc = enc;
            }

            public override int GetByteCount(char[] chars)
            {
                return enc.GetByteCount(chars);
            }

            public override int GetByteCount(char[] chars, int index, int count)
            {
                return enc.GetByteCount(chars, index, count);
            }

            public override int GetByteCount(string s)
            {
                return enc.GetByteCount(s);
            }

            public override byte[] GetBytes(char[] chars)
            {
                return enc.GetBytes(chars);
            }

            public override int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex)
            {
                return enc.GetBytes(chars, charIndex, charCount, bytes, byteIndex);
            }

            public override byte[] GetBytes(char[] chars, int index, int count)
            {
                return enc.GetBytes(chars, index, count);
            }

            public override byte[] GetBytes(string s)
            {
                return enc.GetBytes(s);
            }

            public override int GetBytes(string s, int charIndex, int charCount, byte[] bytes, int byteIndex)
            {
                return enc.GetBytes(s, charIndex, charCount, bytes, byteIndex);
            }

            public override int GetCharCount(byte[] bytes)
            {
                return enc.GetCharCount(bytes);
            }

            public override int GetCharCount(byte[] bytes, int index, int count)
            {
                return enc.GetCharCount(bytes, index, count);
            }

            public override char[] GetChars(byte[] bytes)
            {
                return enc.GetChars(bytes);
            }

            public override int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex)
            {
                return enc.GetChars(bytes, byteIndex, byteCount, chars, charIndex);
            }

            public override char[] GetChars(byte[] bytes, int index, int count)
            {
                return enc.GetChars(bytes, index, count);
            }

            public override string GetString(byte[] bytes, int start, int count)
            {
                return enc.GetString(bytes, start, count);
            }

            public override string WebName
            {
                get { return enc.WebName; }
            }

            public override int CodePage
            {
                get
                {
                    switch (WebName) {
                        case "utf-16BE":
                        case "unicodeFFFE": return 1201;
                        case "utf-16": return 1200;
                        case "utf-8": return 65001;
                        default: return -1;
                    }
                }
            }

            public override string EncodingName
            {
                get
                {
                    switch (WebName) {
                        case "utf-16BE":
                        case "unicodeFFFE": return "Unicode (Big-Endian)";
                        case "utf-16": return "Unicode";
                        case "utf-8": return "Unicode (UTF-8)";
                        default: return "(Unknown)";
                    }
                }
            }
        }

        // Cyrillic (Windows)
        private sealed class Enc1251 : Encoding
        {
            public static Enc1251 Value;

            #region conversion

            private static char[] charMap = new[] { 
                '\u0000', '\u0001', '\u0002', '\u0003', '\u0004', '\u0005', '\u0006', '\u0007', 
                '\u0008', '\u0009', '\u000A', '\u000B', '\u000C', '\u000D', '\u000E', '\u000F', 
                '\u0010', '\u0011', '\u0012', '\u0013', '\u0014', '\u0015', '\u0016', '\u0017', 
                '\u0018', '\u0019', '\u001A', '\u001B', '\u001C', '\u001D', '\u001E', '\u001F', 
                ' ', '!', '"', '#', '$', '%', '&', '\'', 
                '(', ')', '*', '+', ',', '-', '.', '/', 
                '0', '1', '2', '3', '4', '5', '6', '7', 
                '8', '9', ':', ';', '<', '=', '>', '?', 
                '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 
                'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 
                'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 
                'X', 'Y', 'Z', '[', '\\', ']', '^', '_', 
                '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 
                'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 
                'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 
                'x', 'y', 'z', '{', '|', '}', '~', '\u007F', 
                '\u0402', '\u0403', '\u201A', '\u0453', '\u201E', '\u2026', '\u2020', '\u2021', 
                '\u20AC', '\u2030', '\u0409', '\u2039', '\u040A', '\u040C', '\u040B', '\u040F', 
                '\u0452', '\u2018', '\u2019', '\u201C', '\u201D', '\u2022', '\u2013', '\u2014', 
                '\u0098', '\u2122', '\u0459', '\u203A', '\u045A', '\u045C', '\u045B', '\u045F', 
                '\u00A0', '\u040E', '\u045E', '\u0408', '\u00A4', '\u0490', '\u00A6', '\u00A7', 
                '\u0401', '\u00A9', '\u0404', '\u00AB', '\u00AC', '\u00AD', '\u00AE', '\u0407', 
                '\u00B0', '\u00B1', '\u0406', '\u0456', '\u0491', '\u00B5', '\u00B6', '\u00B7', 
                '\u0451', '\u2116', '\u0454', '\u00BB', '\u0458', '\u0405', '\u0455', '\u0457', 
                '\u0410', '\u0411', '\u0412', '\u0413', '\u0414', '\u0415', '\u0416', '\u0417', 
                '\u0418', '\u0419', '\u041A', '\u041B', '\u041C', '\u041D', '\u041E', '\u041F', 
                '\u0420', '\u0421', '\u0422', '\u0423', '\u0424', '\u0425', '\u0426', '\u0427', 
                '\u0428', '\u0429', '\u042A', '\u042B', '\u042C', '\u042D', '\u042E', '\u042F', 
                '\u0430', '\u0431', '\u0432', '\u0433', '\u0434', '\u0435', '\u0436', '\u0437', 
                '\u0438', '\u0439', '\u043A', '\u043B', '\u043C', '\u043D', '\u043E', '\u043F', 
                '\u0440', '\u0441', '\u0442', '\u0443', '\u0444', '\u0445', '\u0446', '\u0447', 
                '\u0448', '\u0449', '\u044A', '\u044B', '\u044C', '\u044D', '\u044E', '\u044F' };

            public override char[] GetChars(byte[] bytes, int index, int count)
            {
                var result = new char[count];
                for (var i = 0; i < result.Length; i++)
                    result[i] = charMap[bytes[i + index]];
                return result;
            }

            public override byte[] GetBytes(char[] chars, int index, int count)
            {
                var result = new byte[count];
                for (var i = 0; i < result.Length; i++) {
                    var c = chars[i + index];
                    if (c < 128) {
                        result[i] = (byte)c;
                        continue;
                    }
                    switch (c) {
                        case '\u0402': result[i] = 128; break;
                        case '\u0403': result[i] = 129; break;
                        case '\u201A': result[i] = 130; break;
                        case '\u0453': result[i] = 131; break;
                        case '\u201E': result[i] = 132; break;
                        case '\u2026': result[i] = 133; break;
                        case '\u2020': result[i] = 134; break;
                        case '\u2021': result[i] = 135; break;
                        case '\u20AC': result[i] = 136; break;
                        case '\u2030': result[i] = 137; break;
                        case '\u0409': result[i] = 138; break;
                        case '\u2039': result[i] = 139; break;
                        case '\u040A': result[i] = 140; break;
                        case '\u040C': result[i] = 141; break;
                        case '\u040B': result[i] = 142; break;
                        case '\u040F': result[i] = 143; break;
                        case '\u0452': result[i] = 144; break;
                        case '\u2018': result[i] = 145; break;
                        case '\u2019': result[i] = 146; break;
                        case '\u201C': result[i] = 147; break;
                        case '\u201D': result[i] = 148; break;
                        case '\u2022': result[i] = 149; break;
                        case '\u2013': result[i] = 150; break;
                        case '\u2014': result[i] = 151; break;
                        case '\u0098': result[i] = 152; break;
                        case '\u2122': result[i] = 153; break;
                        case '\u0459': result[i] = 154; break;
                        case '\u203A': result[i] = 155; break;
                        case '\u045A': result[i] = 156; break;
                        case '\u045C': result[i] = 157; break;
                        case '\u045B': result[i] = 158; break;
                        case '\u045F': result[i] = 159; break;
                        case '\u00A0': result[i] = 160; break;
                        case '\u040E': result[i] = 161; break;
                        case '\u045E': result[i] = 162; break;
                        case '\u0408': result[i] = 163; break;
                        case '\u00A4': result[i] = 164; break;
                        case '\u0490': result[i] = 165; break;
                        case '\u00A6': result[i] = 166; break;
                        case '\u00A7': result[i] = 167; break;
                        case '\u0401': result[i] = 168; break;
                        case '\u00A9': result[i] = 169; break;
                        case '\u0404': result[i] = 170; break;
                        case '\u00AB': result[i] = 171; break;
                        case '\u00AC': result[i] = 172; break;
                        case '\u00AD': result[i] = 173; break;
                        case '\u00AE': result[i] = 174; break;
                        case '\u0407': result[i] = 175; break;
                        case '\u00B0': result[i] = 176; break;
                        case '\u00B1': result[i] = 177; break;
                        case '\u0406': result[i] = 178; break;
                        case '\u0456': result[i] = 179; break;
                        case '\u0491': result[i] = 180; break;
                        case '\u00B5': result[i] = 181; break;
                        case '\u00B6': result[i] = 182; break;
                        case '\u00B7': result[i] = 183; break;
                        case '\u0451': result[i] = 184; break;
                        case '\u2116': result[i] = 185; break;
                        case '\u0454': result[i] = 186; break;
                        case '\u00BB': result[i] = 187; break;
                        case '\u0458': result[i] = 188; break;
                        case '\u0405': result[i] = 189; break;
                        case '\u0455': result[i] = 190; break;
                        case '\u0457': result[i] = 191; break;
                        case '\u0410': result[i] = 192; break;
                        case '\u0411': result[i] = 193; break;
                        case '\u0412': result[i] = 194; break;
                        case '\u0413': result[i] = 195; break;
                        case '\u0414': result[i] = 196; break;
                        case '\u0415': result[i] = 197; break;
                        case '\u0416': result[i] = 198; break;
                        case '\u0417': result[i] = 199; break;
                        case '\u0418': result[i] = 200; break;
                        case '\u0419': result[i] = 201; break;
                        case '\u041A': result[i] = 202; break;
                        case '\u041B': result[i] = 203; break;
                        case '\u041C': result[i] = 204; break;
                        case '\u041D': result[i] = 205; break;
                        case '\u041E': result[i] = 206; break;
                        case '\u041F': result[i] = 207; break;
                        case '\u0420': result[i] = 208; break;
                        case '\u0421': result[i] = 209; break;
                        case '\u0422': result[i] = 210; break;
                        case '\u0423': result[i] = 211; break;
                        case '\u0424': result[i] = 212; break;
                        case '\u0425': result[i] = 213; break;
                        case '\u0426': result[i] = 214; break;
                        case '\u0427': result[i] = 215; break;
                        case '\u0428': result[i] = 216; break;
                        case '\u0429': result[i] = 217; break;
                        case '\u042A': result[i] = 218; break;
                        case '\u042B': result[i] = 219; break;
                        case '\u042C': result[i] = 220; break;
                        case '\u042D': result[i] = 221; break;
                        case '\u042E': result[i] = 222; break;
                        case '\u042F': result[i] = 223; break;
                        case '\u0430': result[i] = 224; break;
                        case '\u0431': result[i] = 225; break;
                        case '\u0432': result[i] = 226; break;
                        case '\u0433': result[i] = 227; break;
                        case '\u0434': result[i] = 228; break;
                        case '\u0435': result[i] = 229; break;
                        case '\u0436': result[i] = 230; break;
                        case '\u0437': result[i] = 231; break;
                        case '\u0438': result[i] = 232; break;
                        case '\u0439': result[i] = 233; break;
                        case '\u043A': result[i] = 234; break;
                        case '\u043B': result[i] = 235; break;
                        case '\u043C': result[i] = 236; break;
                        case '\u043D': result[i] = 237; break;
                        case '\u043E': result[i] = 238; break;
                        case '\u043F': result[i] = 239; break;
                        case '\u0440': result[i] = 240; break;
                        case '\u0441': result[i] = 241; break;
                        case '\u0442': result[i] = 242; break;
                        case '\u0443': result[i] = 243; break;
                        case '\u0444': result[i] = 244; break;
                        case '\u0445': result[i] = 245; break;
                        case '\u0446': result[i] = 246; break;
                        case '\u0447': result[i] = 247; break;
                        case '\u0448': result[i] = 248; break;
                        case '\u0449': result[i] = 249; break;
                        case '\u044A': result[i] = 250; break;
                        case '\u044B': result[i] = 251; break;
                        case '\u044C': result[i] = 252; break;
                        case '\u044D': result[i] = 253; break;
                        case '\u044E': result[i] = 254; break;
                        case '\u044F': result[i] = 255; break;
                        default: result[i] = (byte)'?'; break;
                    }
                }
                return result;
            }

            public override int GetByteCount(char[] chars, int index, int count)
            {
                return count;
            }

            public override int GetCharCount(byte[] bytes, int index, int count)
            {
                return count;
            }

            #endregion

            public override int CodePage
            {
                get { return 1251; }
            }

            public override string EncodingName
            {
                get { return "Cyrillic (Windows)"; }
            }

            public override string WebName
            {
                get { return "windows-1251"; }
            }
        }

        // US-ASCII
        private sealed class Enc20127 : Encoding
        {
            #region conversion

            public override char[] GetChars(byte[] bytes, int index, int count)
            {
                var result = new char[count];
                for (var i = 0; i < result.Length; i++) {
                    var b = bytes[i + index];
                    result[i] = (b > 127) ? '?' : (char)b;
                }
                return result;
            }

            public override byte[] GetBytes(char[] chars, int index, int count)
            {
                var result = new byte[count];
                for (var i = 0; i < result.Length; i++) {
                    var c = chars[i + index];
                    result[i] = (c > 127) ? (byte)'?' : (byte)c;
                }
                return result;
            }

            public override int GetByteCount(char[] chars, int index, int count)
            {
                return count;
            }

            public override int GetCharCount(byte[] bytes, int index, int count)
            {
                return count;
            }

            #endregion

            public override int CodePage
            {
                get { return 20127; }
            }

            public override string EncodingName
            {
                get { return "US-ASCII"; }
            }

            public override string WebName
            {
                get { return "us-ascii"; }
            }
        }
    }
}
